{"version":3,"sources":["components/AddCategory.js","helpers/GetGif.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInpuntValue","onSubmit","e","preventDefault","console","log","trim","length","categ","type","value","onChange","target","getGif","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","title","id","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setstate","useEffect","then","imgs","useFetchGifs","GifExpertApp","categories","cat","ReactDOM","render","document","getElementById"],"mappings":"2MA0CeA,EAtCK,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EACFC,mBAAS,IADP,mBAChCC,EADgC,KACpBC,EADoB,KAoBvC,OAGI,aAFA,CAEA,QAAMC,SAdW,SAACC,GAElBA,EAAEC,iBACFC,QAAQC,IAAI,gBAERN,EAAWO,OAAOC,OAAS,IAC3BV,GAAe,SAAAW,GAAK,OAAKT,GAAL,mBAAoBS,OACxCR,EAAe,MAOnB,SACI,uBACIS,KAAK,OACLC,MAAOX,EAEPY,SAxBc,SAACT,GAEvBF,EAAeE,EAAEU,OAAOF,a,+BCVnBG,EAAM,uCAAG,WAAQC,GAAR,uBAAAC,EAAA,6DACZC,EADY,iDACoCC,UAAUH,GAD9C,+DAECI,MAAMF,GAFP,cAEZG,EAFY,gBAGKA,EAAKC,OAHV,uBAGVC,EAHU,EAGVA,KAEFC,EAAOD,EAAKE,KAAI,SAAAC,GAClB,MAAO,CACHC,MAAOD,EAAIC,MACXC,GAAIF,EAAIE,GACRV,IAAKQ,EAAIG,OAAOC,iBAAiBZ,QATvB,kBAaXM,GAbW,4CAAH,sDCWJO,EATY,SAAC,GAAuB,EAArBH,GAAsB,IAAlBD,EAAiB,EAAjBA,MAAOT,EAAU,EAAVA,IACrC,OACI,sBAAKc,UAAU,yDAAf,UACI,qBAAKC,IAAKf,EAAKgB,IAAKP,IACpB,oBAAGK,UAAU,QAAb,cAAwBL,EAAxB,WCCCQ,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECHb,SAAEA,GAAc,IAAD,EAEbhB,mBAAS,CAC/BuB,KAAM,GACNa,SAAS,IAJ0B,mBAEhCC,EAFgC,KAEzBC,EAFyB,KAkBvC,OAXAC,qBAAU,WACNxB,EAAQC,GAAWwB,MAAK,SAAAC,GACpBH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAGlB,CAACpB,IAIGqB,EDbyBK,CAAa1B,GAAhCa,EAFwB,EAE9BN,KAAca,EAFgB,EAEhBA,QAErB,OACI,qCACI,oBAAIJ,UAAU,4DAAd,SAA2EhB,IAG1EoB,GAAW,mBAAGJ,UAAU,iDAAb,qBAEZ,qBAAKA,UAAY,YAAjB,SAIQH,EAAOJ,KAAI,SAAAC,GAAG,OACd,cAAC,EAAD,eAEQA,GADGA,EAAIE,SAMvB,2BEOGe,EAjCM,WAAM,MAKW3C,mBAAS,CAAC,gBALrB,mBAKlB4C,EALkB,KAKN7C,EALM,KAWzB,OACM,qCACE,8CACA,cAAC,EAAD,CAAaA,cAAkBA,IAE/B,uBACA,6BAKI6C,EAAWnB,KAAK,SAAAoB,GAAG,OACjB,cAAC,EAAD,CAEA7B,SAAY6B,GADLA,YCvBvBC,IAASC,OACL,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.8333f5dd.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\n//tenemos que desestructurar lo que nos llega como properties...\nconst AddCategory = ({ setCategories }) => {\n    const [inputValue, setInpuntValue] = useState('');\n\n    //utilizamos este handle para determinar los value que va tomando el input\n    const handleInputChange = (e) => {\n        //para obtener el valor actual, seteamos el inputValue con el evento.target.value\n        setInpuntValue(e.target.value);\n    }\n\n    const handleSubmit = (e) => {\n        //esto es para prevenir el comportamiento por defecto, y que no se nos refresque el navegador\n        e.preventDefault();\n        console.log('Submit hecho');\n\n        if (inputValue.trim().length > 2) {\n            setCategories( categ => [inputValue, ...categ]);\n            setInpuntValue('');\n        }\n    }\n\n    return (\n        //nosotros definiamos el <> para agrupar todo lo que queriamos utilizar en nuestro componente, sin embargo el form ya es\n        //un agrupador entonces no es necesario incluir el <>\n        <form onSubmit= {handleSubmit}>\n            <input\n                type=\"text\"\n                value={inputValue}\n                //cuando el evento cambie, debemos llamar al handle\n                onChange={handleInputChange}\n            />\n        </form>\n    )\n}\n\nAddCategory.propTypes = {\n    setCategories: PropTypes.func.isRequired\n}\n\nexport default AddCategory;","export const getGif = async ( category ) => {\n    const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=20&api_key=W0hha8Na7gGudVP3nTcJULDLoh1Ehj7x`;\n    const resp = await fetch(url);\n    const { data } = await resp.json();\n\n    const gifs = data.map(img => {\n        return {\n            title: img.title,\n            id: img.id,\n            url: img.images.downsized_medium.url\n        }\n    });\n\n    return gifs;\n};","import React from 'react'\n\nexport const GifGridItem = ( {id, title, url} ) => {\n    return (\n        <div className='card animate__animated animate__bounce animate__faster'>\n            <img src={url} alt={title}></img>\n            <p className='title'> { title } </p>\n        </div>\n    )\n}\n\nexport default GifGridItem;","import React, { useState, useEffect } from 'react'\nimport { useFetchGifs } from '../hooks/useFetchGifs';\nimport { getGif } from '../helpers/GetGif';\nimport GifGridItem from './GifGridItem';\n\n//useEffect permite ejecutar cierto código de manera condicional\n\nexport const GifGrid = ({ category }) => {\n\n    const {data: images, loading} = useFetchGifs(category);\n\n    return (\n        <>\n            <h1 className='title animate__animated animate__rotateIn animate__faster'>{category}</h1>\n\n            {/* {loading ? 'Cargando...' : 'Data cargada'} */}\n            {loading && <p className='loading animate__animated animate__backOutLeft'>Loading</p>}\n           \n            <div className = 'card-grid'>\n                \n\n                {\n                    images.map(img => (\n                    <GifGridItem \n                        key= { img.id} \n                        {...img}/>))\n                }\n\n            </div>\n\n            <hr></hr>\n        </>\n    )\n}\n","import { useEffect, useState } from \"react\"\nimport { getGif } from \"../helpers/GetGif\";\n\n\nexport const useFetchGifs = ( category ) =>{\n    \n    const [state, setstate] = useState({\n        data: [],\n        loading: true\n    });\n\n    useEffect(()=>{\n        getGif( category ).then(imgs => {\n            setstate({\n                data: imgs,\n                loading: false\n            });\n        })\n    }, [category]);\n     //si la category cambia, entonces nuestro componente se va a volver a ejecutar\n    // //si nosotros enviamos el array vacío [] entonces el useEffect va a ejecutar la petición una única vez...\n\n    return state; //{data: [], loading: true}\n}","import React, {useState} from 'react'\nimport AddCategory from './components/AddCategory'\nimport { GifGrid } from './components/GifGrid';\n\nconst GifExpertApp = () => {\n  \n  //esto no se usa, a menos que estemos seguros de que no va a cambiar nunca..\n  // const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\n\n  const [categories, setCategories] = useState(['River Plate']);\n\n  // const handleAdd = () => setCategories([...categories, 'Agregando']);\n                        // setCategories(cats => [...cats, 'Agregando']);\n  \n  \n  return (\n        <>\n          <h2>GifExpertApp</h2>\n          <AddCategory setCategories = { setCategories }/>\n\n          <hr/>\n          <ol>\n            {\n              //si queremos iterar un arreglo por ejemplo, no es posible utilizar un for debido a que React espera que nosotros\n              // retornemos un valor, por lo que se debe utilizar .map, en el cual definimos un nombre del elemento, utilizandolo\n            // tanto como elemento así como indice, por lo que se lo utiliza en el \"key\"...\n              categories.map( cat => \n                <GifGrid\n                key = {cat} \n                category = {cat}/>\n            )}\n          </ol>        \n        </>\n    );\n}\n\n\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GifExpertApp from './GifExpertApp'\n\nReactDOM.render(\n    <GifExpertApp />,\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}